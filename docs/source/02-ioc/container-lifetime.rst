Жизненный цикл компонентов
==========================

**Жизненный цикл** компонента определяет то, как долго экземпляр компонента будет доступен для использования в приложении,
начиная с момента его создания и заканчивая моментом его :ref:`освобождения <dispose>`. По продолжительности жизненного
цикла компоненты приложения InfinniPlatform можно поделить на следующие типы:

* Создаются при каждом получении
* Создаются на время обработки запроса
* Создаются на время работы приложения

Если компонент не имеет внутреннего состояния и используется на протяжении работы приложения, то имеет смысл создать разделяемый
экземпляр компонента в начале работы приложения и освободить его в конце. Если компонент имеет внутреннее состояние, не связанное
с обработкой запроса, экземпляр компонента придется создавать перед первым обращением к нему и освобождать сразу после использования.
При разработке следует стремиться к тому, чтобы компоненты не имели состояния, так как это снизит количество потенциальных ошибок
и уменьшит количество потребляемых ресурсов. 


.. index:: IContainerRegistrationRule.InstancePerDependency()
.. index:: IContainerRegistrationRule.InstancePerRequest()
.. index:: IContainerRegistrationRule.SingleInstance()

Определение жизненного цикла
---------------------------- 

IoC-контейнер осуществляет автоматический контроль жизненного цикла компонентов, поэтому тип их жизненного цикла указывается
при :doc:`регистрации <container-builder>`. По умолчанию все регистрируемые компоненты создаются при каждом получении. 

.. code-block:: csharp

    // Компонент будет создаваться при каждом получении (поведение по умолчанию)
    builder.RegisterType<MyComponent>().As<IMyService>().InstancePerDependency();

    // Компонент будет создаваться на время обработки HTTP-запроса
    builder.RegisterType<MyComponent>().As<IMyService>().InstancePerRequest();

    // Компонент будет создан единожды на время работы приложения 
    builder.RegisterType<MyComponent>().As<IMyService>().SingleInstance();

По окончании жизненного цикла компонента IoC-контейнер :ref:`освобождает <dispose>` экземпляр компонента, и он становится недоступным
для дальнейшего использования. По этой причине при определении жизненного цикла компонентов обязательно следует учитывать их взаимосвязь.
Например, компонент типа ``SingleInstance()`` не может напрямую зависеть от компонента типа ``InstancePerDependency()``

.. table:: Допустимые прямые зависимости

    +-----------------------------+-------------------------------+
    | Исходный тип                | Может ссылаться на            |
    +=============================+===============================+
    | ``InstancePerDependency()`` | * ``InstancePerDependency()`` |
    |                             | * ``InstancePerRequest()``    |
    |                             | * ``SingleInstance()``        |
    +-----------------------------+-------------------------------+
    | ``InstancePerRequest()``    | * ``InstancePerRequest()``    |
    |                             | * ``SingleInstance()``        |
    +-----------------------------+-------------------------------+
    | ``SingleInstance()``        | * ``SingleInstance()``        |
    +-----------------------------+-------------------------------+

Если жизненный цикл компонента дольше, чем жизненный цикл компонента, от которого он зависит, для получения зависимости следует использовать
:ref:`фабричную функцию <resolve-func>`. В следующем примере компонент ``A`` зависит от компонента ``B``, но получает эту зависимость только
перед ее использованием, поскольку жизненный цикл компонента ``A`` дольше жизненного цикла компонента ``B``.

.. code-block:: csharp
   :emphasize-lines: 1,2,10,17

    builder.RegisterType<A>().AsSelf().SingleInstance();
    builder.RegisterType<B>().AsSelf().InstancePerDependency();

    // ...

    public class A
    {
        private readonly Func<B> _b;
    
        public A(Func<B> b)
        {
            _b = b;
        }
    
        public void SomeMethod()
        {
            var b = _b();
    
            b.DoSomething();
        }
    }


.. _dispose:
.. index:: IContainerRegistrationRule.ExternallyOwned()

Освобождение компонентов
------------------------

Приложение может обращаться к ресурсам, которые создаются только на время выполнения какой-то работы. Например, подключение к базе данных,
файловый поток и т.п. Модель .NET предоставляет интерфейс ``IDisposable``, который должны реализовывать все освобождаемые ресурсы.

По окончании жизненного цикла компонента IoC-контейнер проверяет, реализует ли он интерфейс ``IDisposable``, и, если да, то вызывает
у него метод ``Dispose()``. После этого текущий экземпляр компонента становится недоступным для дальнейшего использования.

Чтобы запретить автоматическое освобождение, при регистрации необходимо явно вызвать метод ``ExternallyOwned()``. Это чаще всего актуально
при использовании компонентов, жизненный цикл которых контролируется внешними механизмами, например, сторонними компонентами.

.. code-block:: csharp

    public class DisposableComponent : IDisposable { /* ... */ }

    // ...

    builder.RegisterType<DisposableComponent>().ExternallyOwned();
